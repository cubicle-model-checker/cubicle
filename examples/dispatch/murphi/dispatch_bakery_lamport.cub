(*number_procs 3*)

type t = A1 | A2 | A3 | A4 | None
type d = Z | One | Two | Three | Four | Five

type pc = Empty | L2_1 | L2_2 | L2_3 | L3_1 | L3_2 | L3_3 | L4_1 | L4_2 | L4_3 |  L5_1 | L5_2 | L5_3 | L2_1_1

(*---- Bakery Lamport ----*)
type location = NCS | Choose | Wait | CS
(*------------------*)


array Cmd[proc] : t
array Data[proc] : d
array PC1[proc] : pc
array PC2[proc] : pc

var C : t
var P : proc

var Sync : bool

(*---- Bakery Lamport ----*)

array PC[proc] : location
array Ticket[proc] : int
array Num[proc] : int
var Max : int


(*------------------*)

(*
(1)  Max = 0
(2)  Max < 0
(3)  Max < Num[#1]
(4)  Max < Ticket[#1]
(5)  PC[#1] = CS && Num[#1] = 0
(6)  PC[#1] = Wait && Num[#1] = 0
(7)  PC[#1] = Choose && Ticket[#1] = 0
(8)  Sync = @MFalse && Num[#1] = Max
(9)  Sync = @MFalse && PC[#1] = Choose
(10)  Sync = @MFalse && PC[#1] = Wait
*)

init (i j) { C = None && Cmd[i] = None && Data[i] = Z && PC1[i] = Empty && PC2[i] = Empty && Sync = False &&
     PC[i] = NCS && Num[i] = 0 && 
           Max = 1 && Ticket[i] = 0

}

	  

unsafe (x y) { PC[x] = CS && PC[y] = CS }



transition choix1(i)
requires { Cmd[i] = None }
{
 Cmd[i] := A1
}


transition choix2(i)
requires { Cmd[i] = None }
{
 Cmd[i] := A2
}


transition choix3(i)
requires { Cmd[i] = None }
{
 Cmd[i] := A3
}


transition choix4(i)
requires { Cmd[i] = None }
{
 Cmd[i] := A4
}


(*
transition data1(i)
requires { PC1[i] <> Empty ||  PC2[i] <> Empty }
{
 Data[i] := One
}


transition data2_1(i)
requires { PC1[i] <> Empty ||  PC2[i] <> Empty }
{
 Data[i] := Two
}

transition data3(i)
requires { PC1[i] <> Empty  ||  PC2[i] <> Empty }
{
 Data[i] := Three
}


transition data4(i)
requires { PC1[i] <> Empty ||  PC2[i] <> Empty }
{
 Data[i] := Four;
}

transition data5(i)
requires { PC1[i] <> Empty  ||  PC2[i] <> Empty }
{
 Data[i] := Five;
}
*)
transition cmd1(i)
requires { Cmd[i] = A1 && C = None }
{
 C := A1;
 Cmd[i] := None;
 P := i;
}


transition cmd2(i)
requires { Cmd[i] = A2 && C = None}
{
 C := A2;
 Cmd[i] := None;
 P := i;
}


transition cmd3(i)
requires { Cmd[i] = A3 && C = None}
{
 C := A3;
 Cmd[i] := None;
 P := i;
}

transition cmd4(i)
requires { Cmd[i] = A4 && C = None}
{
 C := A4;
 Cmd[i] := None;
 P := i;
}

transition process_A1(i j)
requires { C = A1 && P = i && PC1[i] = Empty }
{ PC1[i] := L2_1 ; C := None; P := j;  }


transition process_A2(i j)
requires { C = A2 && P = i && PC1[i] = Empty }
{ PC1[i] := L3_1 ; C := None; P := j; }

transition process_A3(i j)
requires { C = A3 && P = i && PC1[i] = Empty }
{ PC1[i] := L4_1 ; C := None; P := j; }

transition process_A4(i j)
requires { C = A4 && P = i && PC1[i] = Empty }
{ PC1[i] := L5_1 ; C := None; P := j; }

transition seq2_1(i)
requires { PC1[i] = L2_1 }
{ PC1[i] := L2_1_1; }

transition seq2_1_1(i)
requires { PC1[i] = L2_1_1 }
{ PC1[i] := L2_2; }

transition seq2_2(i)
requires { PC1[i] = L2_2 }
{ PC1[i] := Empty;
  PC2[i] := L2_3; }

transition seq2_3(i)
requires { PC2[i] = L2_3 }
{ PC2[i] := Empty; }

transition seq3_1(i)
requires { PC1[i] = L3_1 }
{ PC1[i] := L3_2; }

transition seq3_2(i)
requires { PC1[i] = L3_2 }
{ PC1[i] := Empty;
  PC2[i] := L3_3; }

transition seq3_3(i)
requires { PC2[i] = L3_3 }
{ PC2[i] := Empty; }


transition seq4_1(i)
requires { PC1[i] = L4_1 }
{ PC1[i] := L4_2; }

transition seq4_2(i)
requires { PC1[i] = L4_2 }
{ PC1[i] := Empty;
  PC2[i] := L4_3; }

transition seq4_3(i)
requires { PC2[i] = L4_3 }
{ PC2[i] := Empty; }


transition seq5_1(i)
requires { PC1[i] = L5_1 }
{ PC1[i] := L5_2; }

transition seq5_2(i)
requires { PC1[i] = L5_2 }
{ PC1[i] := Empty;
  PC2[i] := L5_3; }

transition seq5_3(i)
requires { PC2[i] = L5_3 }
{ PC2[i] := Empty; }

transition sync(i j m)
requires {Sync = False && PC2[i] = L5_3 && PC1[j] = L5_1 && PC2[m] = L4_3 && forall_other k. PC2[k] = L5_3}
{ PC2[l] := case | _ : Empty;
  Sync := True } 


(*--------- Bakery Lamport ---------*)


transition next_ticket ()
requires { Sync = True }
{ 
  Ticket[j] := case | _ : Max;
  (*Max := Max + 1;*)
}

transition take_ticket (x)
requires {  Sync = True && PC[x] = NCS &&
    forall_other j. Num[j] < Max }
{
  PC[x] := Choose;
  Ticket[x] := Max;
}

transition wait1 (x)
requires {  Sync = True && PC[x] = Choose }
{
  PC[x] := Wait;
  Num[x] := Ticket[x];
}



transition turn_1 (x)
requires { Sync = True && PC[x] = Wait && 
  forall_other j. 
  (PC[j] <> Choose && Num[j] = 0) }
{
  PC[x] := CS;
}


transition turn_2 (x)
requires { Sync = True && PC[x] = Wait && 
  forall_other j. 
  (
   PC[j] <> Choose && Num[x] < Num[j] ) }
{
  PC[x] := CS;
}


transition turn_3 (x)
requires { Sync = True && PC[x] = Wait && 
  forall_other j. 
  (PC[j] <> Choose &&
   Num[x] = Num[j] && x < j) }
{
  PC[x] := CS;
}

transition exit (x)
requires {  Sync = True && PC[x] = CS }
{
  PC[x] := NCS;
  Num[x] := 0;
}

