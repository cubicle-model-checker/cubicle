type t = Idle | Wait | Crit | Linf | Lsup




array A[proc] : t
array Cpt[proc,proc] : bool

(*
init (z y) { A[z] = { state = Lsup } && Cpt[z,y] = { c = False }}

unsafe (x y ) { A[x] = {state = Crit} && A[y] = { state = Crit}}*)

init (z y) { A[z]= (*Idle*) Lsup  && Cpt[z,y] = False }

unsafe (x y ) { A[x] = Crit&& A[y]= Crit}

(*

transition t1(z)
requires { A[z].state = Idle}
{ A[z] := { state = Lsup }
}
*)
transition sup_exit (z)
requires { A[z] = Lsup && forall_other j. Cpt[z,j] = True}
{ Cpt[x,y] := case | x = z : False| _ : Cpt[x,y];
  A[z] := (*Wait*) Linf 
}
(*
transition sup_incr1(z j)
requires{ A[z].state = Lsup  && j < z && Cpt[z,j].c = False }
{ Cpt[z,j] := { c = True }
}

transition sup_incr2(z j)
requires { A[z].state = Lsup  && z < j && A[j].state=  Idle && Cpt[z,j].c = False}
{ Cpt[z,j] := { c = True};
}

transition sup_abort (z j)
requires { A[z] = { state = Lsup } && z < j && A[j].state <> Idle && Cpt[z,j].c =False}
{ Cpt[x,y] := case | x = z : { c = False } | _ : Cpt[x,y]
}

transition t2(z)
requires {A[z].state = Wait }
{ A[z] := { state = Linf} }
*)
transition inf_exit (z)
requires { A[z] = Linf && forall_other j. Cpt[z,j] = True}
{ Cpt[x,y] := case | x = z : False | _ : Cpt[x,y];
  A[z] :=  Crit 
  }

transition inf_incr1 (z j)
requires { A[z] = Linf && z < j && Cpt[z,j]= False} 
{ Cpt[z,j] := True}
(*
transition inf_incr2 (z j)
requires { A[z].state = Linf && j < z && A[j].state = Idle && Cpt[z,j].c = False}
{ Cpt[z,j] := { c = True};
}
*)
transition inf_abort(z j)
requires {A[z] = Linf && j < z && A[j] <> Idle && Cpt[z,j] = False }
{ Cpt[x,y] := case | x = z : False | _ : Cpt[x,y];
}
(*
transition tr3 (z)
requires {A[z].state = Crit }
{ A[z] := { state = Idle }}*)