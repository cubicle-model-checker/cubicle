type t = None | WaitEnter | WaitIf | WaitFor | WaitExit

var Sense : bool 
array LocalSense[proc] : bool
var Count : int 
array PC[proc] : t
array Cnt[proc] : int

var C : condition 

init(i) {
 Cnt[i] = 0 &&
 Sense = False && LocalSense[i] = False  && Count = SYS_PROCS && PC[i] = None}

unsafe(i j) { Cnt[i] <> Cnt[j] &&  PC[i] = None &&  PC[j] = None }

transition wait(i)
requires { PC[i] = None }
{ PC[i] := WaitEnter;
  Cnt[i] := Cnt[i] + 1;
  acquire(C,i);
}

transition last(i)
requires { PC[i] = WaitEnter && Count = 1 }
{
  let s = not LocalSense[i] in
  Sense := s;
  LocalSense[i] := s;
  Count := SYS_PROCS;
  notify_all(C,i);
  PC[i] := None;
}

transition wait_not_last(i)
requires { PC[i] = WaitEnter && Count > 1 && LocalSense[i] <> Sense}
{
  PC[i] := WaitFor;
  wait(C,i);
}

transition wait_exit(i)
requires { PC[i] = WaitFor && Count > 1 && LocalSense[i] = Sense }
{
  release(C, i);
  PC[i] := None;
} 
