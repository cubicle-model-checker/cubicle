##########################################################################
#                                                                        #
#     The Alt-ergo theorem prover                                        #
#     Copyright (C) 2006-2010                                            #
#                                                                        #
#     Sylvain Conchon                                                    #
#     Evelyne Contejean                                                  #
#     Stephane Lescuyer                                                  #
#     Mohamed Iguernelala                                                #
#     Alain Mebsout                                                      #
#                                                                        #
#     CNRS - INRIA - Universite Paris Sud                                #
#                                                                        #
#   This file is distributed under the terms of the CeCILL-C licence     #
#                                                                        #
##########################################################################

# sample Makefile for Objective Caml
# Copyright (C) 2001 Jean-Christophe FILLIATRE
# 
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Library General Public
# License version 2, as published by the Free Software Foundation.
# 
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# 
# See the GNU Library General Public License version 2 for more details
# (enclosed in the file LGPL).

# where to install the binaries
DESTDIR=
prefix=@prefix@
exec_prefix=@exec_prefix@
BINDIR=$(DESTDIR)@bindir@
LIBDIR=$(DESTDIR)@libdir@/alt-ergo

# where to install the man page
MANDIR=$(DESTDIR)@mandir@

# other variables set by ./configure
OCAMLC   = @OCAMLC@
OCAMLOPT = @OCAMLOPT@
OCAMLDEP = @OCAMLDEP@
OCAMLLEX = @OCAMLLEX@
OCAMLYACC= @OCAMLYACC@
OCAMLLIB = @OCAMLLIB@
OCAMLBEST= @OCAMLBEST@
OCAMLVERSION = @OCAMLVERSION@
OCAMLWEB = @OCAMLWEB@
OCAMLWIN32 = @OCAMLWIN32@
EXE = @EXE@

INCLUDES = @OCAMLGRAPHLIB@ @LABLGTK2LIB@

BFLAGS = -dtypes -g $(INCLUDES) -annot
OFLAGS = -dtypes $(INCLUDES) -annot -for-pack AltErgo

BIBBYTE=nums.cma graph.cma unix.cma

BIBOPT=$(BIBBYTE:.cma=.cmxa)

BIBGUIOPT=threads.cmxa lablgtk.cmxa lablgtksourceview2.cmxa gtkThread.cmx 

# main target
#############

NAME = alt-ergo
LIBNAME = altErgo
BYTE=$(NAME).byte
OPT=$(NAME).opt

all: pack xpack $(OCAMLBEST) pack xpack

# bytecode and native-code compilation
######################################

#      printproof.cmo unionfind.cmo \
#      pa.cmo \
#      puf.cmo \
#      satbj.cmo  

PRECMO = version.cmo print_color.cmo preoptions.cmo

OPTIONSCMO = parseoptions.cmo

CMO = options.cmo exception.cmo loc.cmo timer.cmo \
      vec.cmo heap.cmo \
      hashcons.cmo hstring.cmo builtin.cmo symbols.cmo \
      subst.cmo ty.cmo common.cmo term.cmo literal.cmo formula.cmo \
      debug1.cmo solver_types.cmo explanation.cmo \
      why_parser.cmo why_lexer.cmo pretty.cmo \
      smt_parser.cmo smt_lex.cmo smt_to_why.cmo \
      smtlib2_util.cmo smtlib2_ast.cmo \
      smtlib2_parse.cmo smtlib2_lex.cmo smtlib2_to_why.cmo \
      polynome.cmo ac.cmo \
      uf.cmo use.cmo intervals.cmo fm.cmo arith.cmo \
      records.cmo bitv.cmo sum.cmo \
      combine.cmo cc.cmo solver.cmo \
      heap.cmo existantial.cmo \
      triggers.cmo cnf.cmo why_typing.cmo matching.cmo \
      sat.cmo 

CMOFRONT = pruning.cmo frontend.cmo

PRECMX = $(PRECMO:.cmo=.cmx)
OPTIONSCMX = $(OPTIONSCMO:.cmo=.cmx)
CMX = $(CMO:.cmo=.cmx)
CMXFRONT = $(CMOFRONT:.cmo=.cmx)

MAINCMO = $(CMO) $(CMOFRONT) main.cmo
MAINCMX = $(MAINCMO:.cmo=.cmx)

RUNCMO = $(CMO) run.cmo
RUNCMX = $(RUNCMO:.cmo=.cmx)

GENERATED = version.ml \
	why_parser.ml why_parser.mli why_lexer.ml \
	smt_parser.ml smt_parser.mli smt_lex.ml \
	smtlib2_parse.ml smtlib2_parse.mli smtlib2_lex.ml

GUICMO = $(CMO) $(CMOFRONT) why_annoted.cmo why_connected.cmo gui.cmo
GUICMX = $(GUICMO:.cmo=.cmx)

byte: $(NAME).byte
opt: $(NAME).opt

$(NAME).byte: $(PRECMO) $(OPTIONSCMO) $(MAINCMO) 
	$(if $(QUIET),@echo 'Linking $@' &&) 
	$(OCAMLC) $(BFLAGS) -o $@ $(BIBBYTE) $^

$(LIBNAME).cmo: $(PRECMO) $(CMO) 
	$(if $(QUIET),@echo 'Library $@' &&) 
	$(OCAMLC) $(BFLAGS) -pack -o $(LIBNAME).cmo $^

pack: $(LIBNAME).cmo

$(LIBNAME).cmx: $(PRECMX) $(CMX)
	$(if $(QUIET),@echo 'Library $@' &&) 
	$(OCAMLOPT) $(INCLUDES)  -pack -o $(LIBNAME).cmx $^

xpack: $(LIBNAME).cmx

$(NAME).opt: $(PRECMX) $(OPTIONSCMX) $(MAINCMX)
	$(if $(QUIET),@echo 'Linking $@' &&) 
	$(OCAMLOPT) $(OFLAGS) -o $@ $(BIBOPT) $^

gui: $(GUICMX)
	$(if $(QUIET),@echo 'Linking $@' &&) 
	$(OCAMLOPT) $(OFLAGS) -o altgr-ergo.opt $(BIBOPT) $(BIBGUIOPT) $^


run: $(MAINCMX)
	$(OCAMLOPT) -ccopt -static $(OFLAGS) -o $@ $(BIBOPT) $^
	strip $@
	tar -czvf alt-ergo.tgz run smt_prelude.mlw

test: $(OPT)
	./$(OPT) test.mlw

testbyte:$(BYTE)
	tests/test.sh $(BYTE) -glouton

testopt:$(OPT)
	make -C util/
	tests/test.sh " ./$(OPT) -glouton -triggers-var -arrays "

testproof:$(OPT)
	make -C util/
	tests/test.sh " ./$(OPT) -glouton -triggers-var -arrays -proof -debug-proof"

challenge:$(OPT)
	make -C util/
	tests/challenge.sh " ./$(OPT) "


testoptsel:$(OPT)
	tests/test.sh "./$(OPT) -select 2 -glouton -triggers-var "

VERSION=0.93-satml

version.ml: config.status
	@echo "let version = \""$(VERSION)"\"" > version.ml
	@echo "let date = \""`date`"\"" >> version.ml
	@echo "let libdir = \""$(LIBDIR)"\"" >> version.ml



# file headers
##############
headers:
	headache -c doc/headache_config.txt -h doc/alt-ergoheader.txt \
		Makefile.in configure.in README INSTALL \
		*.ml *.ml[ily]


# installation
##############

install-indep: install-man install-prelude install-pack

install: install-indep 
	mkdir -p $(BINDIR)
	cp -f $(NAME).$(OCAMLBEST) $(BINDIR)/$(NAME)$(EXE)

install-byte: install-indep
	mkdir -p $(BINDIR)
	cp -f $(NAME).byte $(BINDIR)/$(NAME)$(EXE)

install-opt: install-indep
	mkdir -p $(BINDIR)
	cp -f $(NAME).opt $(BINDIR)/$(NAME)$(EXE)

install-man:
	mkdir -p $(MANDIR)/man1
	cp -f doc/*.1 $(MANDIR)/man1

install-prelude: smt_prelude.mlw
	mkdir -p $(LIBDIR)
	cp -f $^ $(LIBDIR)

install-gui: install-indep
	mkdir -p $(BINDIR)
	cp -f altgr-ergo.opt $(BINDIR)/altgr-ergo$(EXE)
	cp -f util/gtk-lang/alt-ergo.lang /usr/share/gtksourceview-2.0/language-specs/alt-ergo.lang

install-pack: xpack pack
	mkdir -p $(LIBDIR)
	cp -f $(LIBNAME).cmx $(LIBDIR)
	cp -f $(LIBNAME).o $(LIBDIR)
	cp -f $(LIBNAME).cmo $(LIBDIR)
	cp -f $(LIBNAME).cmi $(LIBDIR)

# documentation
###############

DOCFILES=

doc: $(DOCFILES)

# export
########

EXPORTDIR=$(NAME)-$(VERSION)
TAR=$(EXPORTDIR).tar

HTTP = $$HOME/WWW/ergo/http
ERGOWEB = $$HOME/WWW/ergo/

FILES = version.sh.in version.ml exception.mli exception.ml \
	print_color.mli print_color.ml \
	options.mli options.ml \
	loc.ml sig.mli \
	heap.mli heap.ml hashcons.mli hashcons.ml \
	builtin.mli builtin.ml \
	hstring.mli hstring.ml	\
	symbols.ml symbols.mli \
	subst.mli subst.ml \
	ty.mli ty.ml \
	common.mli common.ml \
	term.mli term.ml \
	literal.mli literal.ml \
	formula.mli formula.ml \
	explanation.mli explanation.ml \
	why_ptree.mli why_parser.mly why_lexer.mll \
	smt_ast.mli smt_parser.mly smt_lex.mll smt_to_why.ml \
	smtlib2_util.ml smtlib2_ast.ml \
	smtlib2_parse.mly smtlib2_lex.mll smtlib2_to_why.ml \
	pruning.mli pruning.ml \
	existantial.mli existantial.ml \
	triggers.mli triggers.ml \
	cnf.mli cnf.ml \
	why_typing.mli why_typing.ml \
	pretty.mli pretty.ml \
	polynome.mli polynome.ml \
	uf.mli uf.ml \
	use.mli use.ml \
	intervals.mli intervals.ml \
	fm.mli fm.ml \
	arith.mli arith.ml \
	records.mli records.ml \
	arrays.ml arrays.mli \
	sum.ml sum.mli \
	bitv.mli bitv.ml \
	combine.mli combine.ml cc.mli cc.ml ac.ml ac.mli\
	matching.mli matching.ml \
	sat.mli sat.ml \
	frontend.mli frontend.ml \
	why_annoted.mli why_annoted.ml why_connected.mli why_connected.ml\
	gui.ml\
	main.ml \
	Makefile.in configure configure.in   \
	.depend README INSTALL COPYING CeCILL-C CHANGES \
	smt_prelude.mlw

export: source binary
	cp README COPYING CeCILL-C CHANGES doc/*.1 $(HTTP)
#	cp index.html $(ERGOWEB)

source: 
	mkdir -p export/$(EXPORTDIR)
	mkdir -p export/$(EXPORTDIR)/doc
	mkdir -p export/$(EXPORTDIR)/util
	mkdir -p export/$(EXPORTDIR)/util/gtk-lang
	cp $(FILES) export/$(EXPORTDIR)
	cp doc/$(NAME).1 export/$(EXPORTDIR)/doc
	cp util/gtk-lang/alt-ergo.lang export/$(EXPORTDIR)/util/gtk-lang/
	cd export ; tar cf $(TAR) $(EXPORTDIR) ; gzip -f --best $(TAR)
	cp export/$(TAR).gz $(HTTP)


BINARY = $(EXPORTDIR)-$$OSTYPE
BINARYTAR=$(BINARY).tar
ARCH = $(shell uname -m)
BINARYFILES = README INSTALL COPYING CeCILL-C doc/$(NAME).1

binary: $(OPT)
	strip $(OPT)
	cp $(OPT) $(HTTP)/alt-ergo-$(VERSION)-$(ARCH)

# literate programming
######################

SOURCES = 

$(NAME).tex: $(SOURCES)
	$(OCAMLWEB) -o $@ $^

# generic rules
###############

.SUFFIXES: .mli .ml .cmi .cmo .cmx .mll .mly .tex .dvi .ps .html

.mli.cmi:
	@@OCAMLWIZARD@ compile -w a $(BFLAGS) $< 
	$(if $(QUIET),@echo 'Compiling $@' &&) $(OCAMLC) -c $(BFLAGS) $<

.ml.cmo:
	$(if $(QUIET),@echo 'Compiling $@' &&) $(OCAMLC) -c $(BFLAGS) $<
	@@OCAMLWIZARD@ compile -w a $(BFLAGS) $< 

.ml.o:
	@@OCAMLWIZARD@ compile -w a $(BFLAGS) $< 
	$(if $(QUIET),@echo 'Compiling $@' &&) $(OCAMLOPT) -c $(OFLAGS) $<

.ml.cmx:
	$(if $(QUIET),@echo 'Compiling $@' &&) $(OCAMLOPT) -c $(OFLAGS) $<
	@@OCAMLWIZARD@ compile -w a $(BFLAGS) $< 

.mll.ml:
	$(if $(QUIET),@echo 'Compiling $<' &&) $(OCAMLLEX) $< > /dev/null

.mly.ml:
	$(if $(QUIET),@echo 'Compiling $<' &&) $(OCAMLYACC) -v $< 

.mly.mli:
	$(if $(QUIET),@echo 'Compiling $<' &&) $(OCAMLYACC) -v $< 

.tex.dvi:
	latex $< && latex $<

.dvi.ps:
	dvips $< -o $@ 

.tex.html:
	hevea $<

# Emacs tags
############

tags:
	find . -name "*.ml*" | sort -r | xargs \
	etags "--regex=/let[ \t]+\([^ \t]+\)/\1/" \
	      "--regex=/let[ \t]+rec[ \t]+\([^ \t]+\)/\1/" \
	      "--regex=/and[ \t]+\([^ \t]+\)/\1/" \
	      "--regex=/type[ \t]+\([^ \t]+\)/\1/" \
              "--regex=/exception[ \t]+\([^ \t]+\)/\1/" \
	      "--regex=/val[ \t]+\([^ \t]+\)/\1/" \
	      "--regex=/module[ \t]+\([^ \t]+\)/\1/"

# Makefile is rebuilt whenever Makefile.in or configure.in is modified
######################################################################

Makefile: Makefile.in config.status
	./config.status

config.status: configure
	./config.status --recheck

configure: configure.in
	autoconf 

# clean
#######

clean:: 
	@rm -f *.cm[iox] *.o *~ *.annot *.owz *mlocamlwizard_tmp_file*
	@rm -f $(GENERATED) *.output
	@rm -f $(NAME).byte $(NAME).opt
	@rm -f unittest/*.cm[iox] unittest/*.o unittest/*.annot
	@rm -f *.aux *.log $(NAME).tex $(NAME).dvi $(NAME).ps
	@rm -f version.ml

dist-clean distclean:: clean
	@rm -f Makefile config.cache config.log config.status

# depend
########

.depend depend:: $(GENERATED)
	@rm -f .depend
	@$(OCAMLDEP) -slash *.ml *.mli > .depend

include .depend
