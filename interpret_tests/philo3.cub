
type ph = Thinking | Eating | Hungry | GotRightFork | GotBothForks | PutForkDown

array Philosopher[proc] : ph


array Stick[proc] : lock

var Counting : semaphore

(*---------Cheat Neighbors----------*)
var Block : bool
array LeftN[proc] : proc
array RightN[proc] : proc
(*----------------------------------*)


init(i) { Philosopher[i] = Thinking && Block = False && Counting = 4(* &&
	LeftN[k] = case | k = 0 : 5
		    	 | _ : k - 1*)
	
	} 


(*---------Cheat Neighbors----------*)

(*
transition set_neighbor(#1, #5, #2); set_neighbor(#2, #1, #3); set_neighbor(#3, #2, #4) ;set_neighbor(#4, #3, #5);set_neighbor(#5, #4, #1); block()
 *)

transition set_neighbor(i j k)
requires { Block = False }
{ LeftN[i] := j;
  RightN[i] := k }

transition block()
requires {Block = False}
{ Block := True }
(*----------------------------------*)


transition hungry(i)
requires { Philosopher[i] = Thinking }
{ Philosopher[i] := Hungry;
  acquire(Counting,i)
  }

transition get_my_fork(i)
requires { Philosopher[i] = Hungry  }
{ acquire(Stick[i], i);
  Philosopher[i] := GotRightFork }

transition get_right_fork(i j)
requires { Philosopher[i] = GotRightFork && RightN[i] = j }
{ acquire(Stick[j], i);
  Philosopher[i] := GotBothForks; 
}

transition eat(i)
requires { Philosopher[i] = GotBothForks }
{ release(Counting,i);
  Philosopher[i] := Eating }

transition put_right_fork_down(i j)
requires { Philosopher[i] = Eating && RightN[i] = j }
{ release(Stick[j], i);
  Philosopher[i] := PutForkDown }

transition put_left_fork_down(i)
requires { Philosopher[i] = PutForkDown }
{ release(Stick[i], i);
  Philosopher[i] := Thinking } 


(*
transition hungry(#4)
transition hungry(#2)
transition get_left_fork(#4, #3)
transition hungry(#5)
transition get_right_fork(#4, #5)
transition get_left_fork(#2, #1)
transition hungry(#3)
transition get_left_fork(#5, #4)
transition get_right_fork(#2, #3)
transition get_right_fork(#5, #1)
transition hungry(#1)
transition eat(#4)


*)