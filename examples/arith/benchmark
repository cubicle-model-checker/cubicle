#!/usr/bin/env python3
import os
import re
import shutil
import signal
from concurrent.futures import Future, ThreadPoolExecutor, as_completed
from datetime import datetime
from pathlib import Path
from subprocess import PIPE, Popen, TimeoutExpired, run

# Constants
cubicle_git_dir = Path("/home/gurvan/Documents/cubicle/arith/")
OUT_FILE = cubicle_git_dir / "examples" / "arith" / "result.csv"
NB_PROCESS = 6
TIMEOUT_SEC = 60
# End of Constants

time = shutil.which("time")
if time is None:
    raise RuntimeError("Time not found !")

begin_t = datetime.now().replace(microsecond=0)

ARITH = "arith"
BASE = "base"


def find_cubicles() -> dict[str, Path]:
    cubicle_opt = cubicle_git_dir / "cubicle.opt"
    if not cubicle_opt.exists():
        raise RuntimeError("Please Build Cubicle.")

    cubicle = shutil.which("cubicle")
    if cubicle is None:
        raise RuntimeError("Cubicle is not found.")
    cubicle = Path(cubicle)

    return {ARITH: cubicle_opt, BASE: cubicle}


cub_execs = find_cubicles()

test_dir = cubicle_git_dir / "examples"
if not test_dir.exists():
    raise RuntimeError("Where are the examples ?")

examples_list = test_dir.glob("*.cub")

if not OUT_FILE.parent.exists():
    raise RuntimeError("Directory of the out file does not exists !")

safe_re = re.compile("The system is SAFE")
unsafe_re = re.compile("UNSAFE !")
reach_limits = re.compile("Reached Limit !")
spurious = re.compile("Spurious trace")
solver_calls = re.compile(r"solver calls +: (\d+)")
visited_nodes = re.compile(r"visited nodes +: (\d+)")

running_env = os.environ.copy()
running_env["TERM"] = "linux"

STATUS = "status"
TIME_TAKEN = "time"
SOLVER_CALLED = "solver"
NODES_VISITED = "nodes_visited"

TYPE_ERROR = "Type Error"
TIMEOUT = "Timeout"
SPURIOUS_TRACE = "Spurious Trace"
SAFE = "Safe"
UNSAFE = "Unsafe"
REACH_LIMITS = "Reach Limits"
RUN_ERROR = "Parsing or Program Crashed"


def run_with_timeout(args) -> None | tuple[float, str]:
    with Popen([time, "-f", "time:%e"] + args, stdout=PIPE, stderr=PIPE, text=True,
               start_new_session=True, env=running_env) as process:
        try:
            stdout, stderr = process.communicate(timeout=TIMEOUT_SEC)
            data_out = stdout + stderr

            t = float(re.findall(r"time:(\d+\.\d+)", data_out)[0])
        except TimeoutExpired:
            os.killpg(process.pid, signal.SIGINT)
            return None
        except IndexError:
            raise RuntimeError(f"Error Parsing: \n{data_out}")
    return t, data_out


def run_cubicle(cubicle_path: Path, test_file: Path) -> dict:
    c = run([cubicle_path, "-type-only", test_file], env=running_env, stdout=PIPE, stderr=PIPE)
    if c.returncode != 0:
        return {STATUS: TYPE_ERROR, TIME_TAKEN: None, SOLVER_CALLED: None, NODES_VISITED: None}
    else:
        out: None | tuple[float, str] = None
        try:
            out = run_with_timeout([cubicle_path, "-nocolor", str(test_file)])
            if out is None:
                return {STATUS: TIMEOUT, TIME_TAKEN: None, SOLVER_CALLED: None, NODES_VISITED: None}
            else:
                cubicle_time, cubicle_out = out

                sol_c = int(solver_calls.findall(cubicle_out)[0])
                vis_n = int(visited_nodes.findall(cubicle_out)[0])

                if safe_re.findall(cubicle_out):
                    return {STATUS: SAFE, TIME_TAKEN: cubicle_time, SOLVER_CALLED: sol_c,
                            NODES_VISITED: vis_n}
                elif unsafe_re.findall(cubicle_out):
                    return {STATUS: UNSAFE, TIME_TAKEN: cubicle_time, SOLVER_CALLED: sol_c,
                            NODES_VISITED: vis_n}
                elif spurious.findall(cubicle_out):
                    return {STATUS: SPURIOUS_TRACE, TIME_TAKEN: cubicle_time, SOLVER_CALLED: sol_c,
                            NODES_VISITED: vis_n}
                elif reach_limits.findall(cubicle_out):
                    return {STATUS: REACH_LIMITS, TIME_TAKEN: cubicle_time, SOLVER_CALLED: sol_c,
                            NODES_VISITED: vis_n}
                else:
                    raise RuntimeError(f"Unable to parse output: \n{cubicle_out}")
        except Exception as e:
            print("Error in parsing:")
            print(e)

            if out is not None:
                print("Cubicle output:")
                print(out[1])

                return {STATUS: RUN_ERROR, TIME_TAKEN: out[0], SOLVER_CALLED: None,
                        NODES_VISITED: None}
            else:
                return {STATUS: REACH_LIMITS, TIME_TAKEN: None, SOLVER_CALLED: None,
                        NODES_VISITED: None}


def run_all(nb_workers: int) -> dict[str, dict[str, dict]]:
    testing_data = {}
    with ThreadPoolExecutor(max_workers=nb_workers) as executor:
        future_to_file: dict[Future[dict], tuple[Path, str]] = \
            {executor.submit(run_cubicle, cub_execs[mode], file): (file, mode)
             for file in examples_list
             for mode in [ARITH, BASE]}

        test_number = len(future_to_file)

        for nb, future in enumerate(as_completed(future_to_file)):
            tested_file, mode = future_to_file[future]
            cub_result = future.result()
            key = tested_file.stem

            print(
                f"Remaining: {test_number - nb - 1:>3d}/{test_number}. "
                f"Time elapsed: {datetime.now().replace(microsecond=0) - begin_t}. End of {'mode=' + mode + ',':<11} file={key}")

            if key not in testing_data:
                testing_data[key] = {}

            testing_data[key][mode] = cub_result

    return testing_data


def dict_to_list(file: str, run_data: dict[str, dict]) -> list[str]:
    arith, base = run_data[ARITH], run_data[BASE]

    def parse_none(elm: str | int | None) -> str:
        if elm is None:
            return ""
        else:
            return str(elm)

    return [file, parse_none(arith[STATUS]), parse_none(base[STATUS]),
            parse_none(arith[TIME_TAKEN]), parse_none(base[TIME_TAKEN]),
            parse_none(arith[NODES_VISITED]), parse_none(base[NODES_VISITED]),
            parse_none(arith[SOLVER_CALLED]), parse_none(base[SOLVER_CALLED])]


def save_to_csv(data_to_save: dict[str, dict[str, dict]]) -> None:
    if OUT_FILE.exists():
        OUT_FILE.unlink()

    legend = ["File", "Result (Arith)", "Result (Base)", "Time (Arith)", "Time (Base)",
              "Nodes (Arith)", "Nodes (Base)", "Solver Calls (Arith)", "Solver Calls (Base)"]

    with open(OUT_FILE, "w") as f:
        f.write(";".join(legend) + "\n")
        for file in sorted(data_to_save):
            f.write(";".join(dict_to_list(file, data_to_save[file])) + "\n")


if __name__ == '__main__':
    print("Let's Bench !")
    data = run_all(NB_PROCESS)

    print("Saving Data...")
    save_to_csv(data)
